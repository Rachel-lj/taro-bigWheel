(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tarojs/taro')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tarojs/taro'], factory) :
  (factory((global.TaroQq = {}),global.taro));
}(this, (function (exports,taro) { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  /* eslint-disable */
  var objectIs = Object.is || function (x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    }

    return x !== x && y !== y;
  };

  function shallowEqual(obj1, obj2) {
    if (_typeof(obj1) !== 'object' && _typeof(obj2) !== 'object') {
      return obj1 === obj2;
    }

    if (obj1 === null && obj2 === null) {
      return true;
    }

    if (obj1 === null || obj2 === null) {
      return false;
    }

    if (objectIs(obj1, obj2)) {
      return true;
    }

    var obj1Keys = obj1 ? Object.keys(obj1) : [];
    var obj2Keys = obj2 ? Object.keys(obj2) : [];

    if (obj1Keys.length !== obj2Keys.length) {
      return false;
    }

    for (var i = 0; i < obj1Keys.length; i++) {
      var obj1KeyItem = obj1Keys[i];

      if (!obj2.hasOwnProperty(obj1KeyItem) || !objectIs(obj1[obj1KeyItem], obj2[obj1KeyItem])) {
        return false;
      }
    }

    return true;
  }

  var SimpleMap =
  /*#__PURE__*/
  function () {
    function SimpleMap() {
      _classCallCheck(this, SimpleMap);

      this.cache = [];
      this.size = 0;
    }

    _createClass(SimpleMap, [{
      key: "set",
      value: function set(k, v) {
        var len = this.cache.length;

        if (!len) {
          this.cache.push({
            k: k,
            v: v
          });
          this.size += 1;
          return;
        }

        for (var i = 0; i < len; i++) {
          var item = this.cache[i];

          if (item.k === k) {
            item.v = v;
            return;
          }
        }

        this.cache.push({
          k: k,
          v: v
        });
        this.size += 1;
      }
    }, {
      key: "get",
      value: function get(k) {
        var len = this.cache.length;

        if (!len) {
          return;
        }

        for (var i = 0; i < len; i++) {
          var item = this.cache[i];

          if (item.k === k) {
            return item.v;
          }
        }
      }
    }, {
      key: "has",
      value: function has(k) {
        var len = this.cache.length;

        if (!len) {
          return false;
        }

        for (var i = 0; i < len; i++) {
          var item = this.cache[i];

          if (item.k === k) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "delete",
      value: function _delete(k) {
        var len = this.cache.length;

        for (var i = 0; i < len; i++) {
          var item = this.cache[i];

          if (item.k === k) {
            this.cache.splice(i, 1);
            this.size -= 1;
            return true;
          }
        }

        return false;
      }
    }, {
      key: "clear",
      value: function clear() {
        var len = this.cache.length;
        this.size = 0;

        if (!len) {
          return;
        }

        while (len) {
          this.cache.pop();
          len--;
        }
      }
    }]);

    return SimpleMap;
  }();

  function addLeadingSlash(path) {
    return path.charAt(0) === '/' ? path : '/' + path;
  }

  function getCurrentPageUrl() {
    var pages = getCurrentPages();
    var currentPage = pages[pages.length - 1];
    return addLeadingSlash(currentPage.route || currentPage.__route__);
  }

  var nextTick = function nextTick(fn) {
    var _fn;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    fn = typeof fn === 'function' ? (_fn = fn).bind.apply(_fn, [null].concat(args)) : fn;
    var timerFunc = qq.nextTick ? qq.nextTick : setTimeout;
    timerFunc(fn);
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var reactIs_production_min = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var b = "function" === typeof Symbol && Symbol.for,
        c = b ? Symbol.for("react.element") : 60103,
        d = b ? Symbol.for("react.portal") : 60106,
        e = b ? Symbol.for("react.fragment") : 60107,
        f = b ? Symbol.for("react.strict_mode") : 60108,
        g = b ? Symbol.for("react.profiler") : 60114,
        h = b ? Symbol.for("react.provider") : 60109,
        k = b ? Symbol.for("react.context") : 60110,
        l = b ? Symbol.for("react.async_mode") : 60111,
        m = b ? Symbol.for("react.concurrent_mode") : 60111,
        n = b ? Symbol.for("react.forward_ref") : 60112,
        p = b ? Symbol.for("react.suspense") : 60113,
        q = b ? Symbol.for("react.memo") : 60115,
        r = b ? Symbol.for("react.lazy") : 60116;

    function t(a) {
      if ("object" === _typeof(a) && null !== a) {
        var u = a.$$typeof;

        switch (u) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m:
              case e:
              case g:
              case f:
              case p:
                return a;

              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case h:
                    return a;

                  default:
                    return u;
                }

            }

          case r:
          case q:
          case d:
            return u;
        }
      }
    }

    function v(a) {
      return t(a) === m;
    }

    exports.typeOf = t;
    exports.AsyncMode = l;
    exports.ConcurrentMode = m;
    exports.ContextConsumer = k;
    exports.ContextProvider = h;
    exports.Element = c;
    exports.ForwardRef = n;
    exports.Fragment = e;
    exports.Lazy = r;
    exports.Memo = q;
    exports.Portal = d;
    exports.Profiler = g;
    exports.StrictMode = f;
    exports.Suspense = p;

    exports.isValidElementType = function (a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || "object" === _typeof(a) && null !== a && (a.$$typeof === r || a.$$typeof === q || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n);
    };

    exports.isAsyncMode = function (a) {
      return v(a) || t(a) === l;
    };

    exports.isConcurrentMode = v;

    exports.isContextConsumer = function (a) {
      return t(a) === k;
    };

    exports.isContextProvider = function (a) {
      return t(a) === h;
    };

    exports.isElement = function (a) {
      return "object" === _typeof(a) && null !== a && a.$$typeof === c;
    };

    exports.isForwardRef = function (a) {
      return t(a) === n;
    };

    exports.isFragment = function (a) {
      return t(a) === e;
    };

    exports.isLazy = function (a) {
      return t(a) === r;
    };

    exports.isMemo = function (a) {
      return t(a) === q;
    };

    exports.isPortal = function (a) {
      return t(a) === d;
    };

    exports.isProfiler = function (a) {
      return t(a) === g;
    };

    exports.isStrictMode = function (a) {
      return t(a) === f;
    };

    exports.isSuspense = function (a) {
      return t(a) === p;
    };
  });
  unwrapExports(reactIs_production_min);
  var reactIs_production_min_1 = reactIs_production_min.typeOf;
  var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
  var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
  var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
  var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
  var reactIs_production_min_6 = reactIs_production_min.Element;
  var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
  var reactIs_production_min_8 = reactIs_production_min.Fragment;
  var reactIs_production_min_9 = reactIs_production_min.Lazy;
  var reactIs_production_min_10 = reactIs_production_min.Memo;
  var reactIs_production_min_11 = reactIs_production_min.Portal;
  var reactIs_production_min_12 = reactIs_production_min.Profiler;
  var reactIs_production_min_13 = reactIs_production_min.StrictMode;
  var reactIs_production_min_14 = reactIs_production_min.Suspense;
  var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
  var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
  var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
  var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
  var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
  var reactIs_production_min_20 = reactIs_production_min.isElement;
  var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
  var reactIs_production_min_22 = reactIs_production_min.isFragment;
  var reactIs_production_min_23 = reactIs_production_min.isLazy;
  var reactIs_production_min_24 = reactIs_production_min.isMemo;
  var reactIs_production_min_25 = reactIs_production_min.isPortal;
  var reactIs_production_min_26 = reactIs_production_min.isProfiler;
  var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
  var reactIs_production_min_28 = reactIs_production_min.isSuspense;

  var reactIs_development = createCommonjsModule(function (module, exports) {

    if (process.env.NODE_ENV !== "production") {
      (function () {

        Object.defineProperty(exports, '__esModule', {
          value: true
        }); // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.

        var hasSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

        function isValidElementType(type) {
          return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || _typeof(type) === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
        }
        /**
         * Forked from fbjs/warning:
         * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
         *
         * Only change is we use console.warn instead of console.error,
         * and do nothing when 'console' is not supported.
         * This really simplifies the code.
         * ---
         * Similar to invariant but only logs a warning if the condition is not met.
         * This can be used to log issues in development environments in critical
         * paths. Removing the logging code for production environments will keep the
         * same logic and follow the same code paths.
         */


        var lowPriorityWarning = function lowPriorityWarning() {};

        {
          var printWarning = function printWarning(format) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            var argIndex = 0;
            var message = 'Warning: ' + format.replace(/%s/g, function () {
              return args[argIndex++];
            });

            if (typeof console !== 'undefined') {
              console.warn(message);
            }

            try {
              // --- Welcome to debugging React ---
              // This error was thrown as a convenience so that you can use this stack
              // to find the callsite that caused this warning to fire.
              throw new Error(message);
            } catch (x) {}
          };

          lowPriorityWarning = function lowPriorityWarning(condition, format) {
            if (format === undefined) {
              throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
            }

            if (!condition) {
              for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                args[_key2 - 2] = arguments[_key2];
              }

              printWarning.apply(undefined, [format].concat(args));
            }
          };
        }
        var lowPriorityWarning$1 = lowPriorityWarning;

        function typeOf(object) {
          if (_typeof(object) === 'object' && object !== null) {
            var $$typeof = object.$$typeof;

            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;

                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;

                  default:
                    var $$typeofType = type && type.$$typeof;

                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;

                      default:
                        return $$typeof;
                    }

                }

              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }

          return undefined;
        } // AsyncMode is deprecated along with isAsyncMode


        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }

        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }

        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }

        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }

        function isElement(object) {
          return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }

        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }

        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }

        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }

        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }

        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }

        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }

        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }

        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }

        exports.typeOf = typeOf;
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isValidElementType = isValidElementType;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
      })();
    }
  });
  unwrapExports(reactIs_development);
  var reactIs_development_1 = reactIs_development.typeOf;
  var reactIs_development_2 = reactIs_development.AsyncMode;
  var reactIs_development_3 = reactIs_development.ConcurrentMode;
  var reactIs_development_4 = reactIs_development.ContextConsumer;
  var reactIs_development_5 = reactIs_development.ContextProvider;
  var reactIs_development_6 = reactIs_development.Element;
  var reactIs_development_7 = reactIs_development.ForwardRef;
  var reactIs_development_8 = reactIs_development.Fragment;
  var reactIs_development_9 = reactIs_development.Lazy;
  var reactIs_development_10 = reactIs_development.Memo;
  var reactIs_development_11 = reactIs_development.Portal;
  var reactIs_development_12 = reactIs_development.Profiler;
  var reactIs_development_13 = reactIs_development.StrictMode;
  var reactIs_development_14 = reactIs_development.Suspense;
  var reactIs_development_15 = reactIs_development.isValidElementType;
  var reactIs_development_16 = reactIs_development.isAsyncMode;
  var reactIs_development_17 = reactIs_development.isConcurrentMode;
  var reactIs_development_18 = reactIs_development.isContextConsumer;
  var reactIs_development_19 = reactIs_development.isContextProvider;
  var reactIs_development_20 = reactIs_development.isElement;
  var reactIs_development_21 = reactIs_development.isForwardRef;
  var reactIs_development_22 = reactIs_development.isFragment;
  var reactIs_development_23 = reactIs_development.isLazy;
  var reactIs_development_24 = reactIs_development.isMemo;
  var reactIs_development_25 = reactIs_development.isPortal;
  var reactIs_development_26 = reactIs_development.isProfiler;
  var reactIs_development_27 = reactIs_development.isStrictMode;
  var reactIs_development_28 = reactIs_development.isSuspense;

  var reactIs = createCommonjsModule(function (module) {

    if (process.env.NODE_ENV === 'production') {
      module.exports = reactIs_production_min;
    } else {
      module.exports = reactIs_development;
    }
  });

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */

  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      } // Detect buggy property enumeration order in older V8 versions.
      // https://bugs.chromium.org/p/v8/issues/detail?id=4118


      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

      test1[5] = 'de';

      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test2 = {};

      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }

      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });

      if (order2.join('') !== '0123456789') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });

      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  var printWarning = function printWarning() {};

  if (process.env.NODE_ENV !== 'production') {
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    printWarning = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }
  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */


  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if (process.env.NODE_ENV !== 'production') {
      for (var typeSpecName in typeSpecs) {
        if (has(typeSpecs, typeSpecName)) {
          var error; // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.

          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.');
              err.name = 'Invariant Violation';
              throw err;
            }

            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
          } catch (ex) {
            error = ex;
          }

          if (error && !(error instanceof Error)) {
            printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + _typeof(error) + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
          }

          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
          }
        }
      }
    }
  }
  /**
   * Resets warning cache when testing.
   *
   * @private
   */


  checkPropTypes.resetWarningCache = function () {
    if (process.env.NODE_ENV !== 'production') {
      loggedTypeFailures = {};
    }
  };

  var checkPropTypes_1 = checkPropTypes;

  var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

  var printWarning$1 = function printWarning() {};

  if (process.env.NODE_ENV !== 'production') {
    printWarning$1 = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  var factoryWithTypeCheckers = function factoryWithTypeCheckers(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */

    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }
    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */


    var ANONYMOUS = '<<anonymous>>'; // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */

    /*eslint-disable no-self-compare*/

    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */


    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    } // Make `instanceof Error` still work for returned errors.


    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== 'production') {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }

      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret_1) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
            err.name = 'Invariant Violation';
            throw err;
          } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;

            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning$1('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }

        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }

            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }

          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }

        var propValue = props[propName];

        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }

        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);

          if (error instanceof Error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!reactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        if (process.env.NODE_ENV !== 'production') {
          if (arguments.length > 1) {
            printWarning$1('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
          } else {
            printWarning$1('Invalid argument supplied to oneOf, expected an array.');
          }
        }

        return emptyFunctionThatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);

          if (type === 'symbol') {
            return String(value);
          }

          return value;
        });
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }

        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }

        for (var key in propValue) {
          if (has$1(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);

            if (error instanceof Error) {
              return error;
            }
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== 'production' ? printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];

        if (typeof checker !== 'function') {
          printWarning$1('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];

          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        for (var key in shapeTypes) {
          var checker = shapeTypes[key];

          if (!checker) {
            continue;
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        } // We need to check all keys in case some are required but missing from
        // props.


        var allKeys = objectAssign({}, props[propName], shapeTypes);

        for (var key in allKeys) {
          var checker = shapeTypes[key];

          if (!checker) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (_typeof(propValue)) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;

        case 'boolean':
          return !propValue;

        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }

          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);

          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;

            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;

                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;

        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      } // falsy value can't be a Symbol


      if (!propValue) {
        return false;
      } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      } // Fallback for non-spec compliant Symbols which are polyfilled.


      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    } // Equivalent of `typeof` but with special handling for array and regexp.


    function getPropType(propValue) {
      var propType = _typeof(propValue);

      if (Array.isArray(propValue)) {
        return 'array';
      }

      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }

      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }

      return propType;
    } // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.


    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }

      var propType = getPropType(propValue);

      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }

      return propType;
    } // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"


    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);

      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;

        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;

        default:
          return type;
      }
    } // Returns class name of the object, if any.


    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }

      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes_1;
    ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };

  function emptyFunction() {}

  function emptyFunctionWithReset() {}

  emptyFunctionWithReset.resetWarningCache = emptyFunction;

  var factoryWithThrowingShims = function factoryWithThrowingShims() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret_1) {
        // It is still safe when called from React.
        return;
      }

      var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
      err.name = 'Invariant Violation';
      throw err;
    }
    shim.isRequired = shim;

    function getShim() {
      return shim;
    }
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };

  var propTypes = createCommonjsModule(function (module) {
    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    if (process.env.NODE_ENV !== 'production') {
      var ReactIs = reactIs; // By explicitly using `prop-types` you are opting into new development behavior.
      // http://fb.me/prop-types-in-prod

      var throwOnDirectAccess = true;
      module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
    } else {
      // By explicitly using `prop-types` you are opting into new production behavior.
      // http://fb.me/prop-types-in-prod
      module.exports = factoryWithThrowingShims();
    }
  });

  /** Detect free variable `global` from Node.js. */

  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;

  /** Built-in value references. */

  var _Symbol2 = _root.Symbol;
  var _Symbol = _Symbol2;

  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$1 = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty$1.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /** Built-in value references. */

  var getPrototype = _overArg(Object.getPrototypeOf, Object);
  var _getPrototype = getPrototype;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && _typeof(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */

  var objectTag = '[object Object]';
  /** Used for built-in method references. */

  var funcProto = Function.prototype,
      objectProto$2 = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString.call(Object);
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */

  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
      return false;
    }

    var proto = _getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;

  function isEmptyObject(obj) {
    if (!obj || !isPlainObject_1(obj)) {
      return false;
    }

    for (var n in obj) {
      if (obj.hasOwnProperty(n)) {
        return false;
      }
    }

    return true;
  }
  function isUndefined(o) {
    return o === undefined;
  }
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  function isArray(arg) {
    return Array.isArray(arg);
  }
  function shakeFnFromObject(obj) {
    var newObj;

    if (isArray(obj)) {
      newObj = [];
      var len = obj.length;

      for (var i = 0; i < len; i++) {
        newObj.push(shakeFnFromObject(obj[i]));
      }
    } else if (isPlainObject_1(obj)) {
      newObj = {};

      for (var key in obj) {
        if (isFunction(obj[key])) {
          continue;
        }

        var ret = shakeFnFromObject(obj[key]);
        newObj[key] = ret;
      }
    } else {
      return obj;
    }

    return newObj;
  }
  var keyList = Object.keys;
  var hasProp = Object.prototype.hasOwnProperty;

  function diffArrToPath(to, from) {
    var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var keyPrev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var len = to.length;

    var _loop = function _loop(i) {
      var toItem = to[i];
      var fromItem = from[i];
      var targetKey = "".concat(keyPrev, "[").concat(i, "]");

      if (toItem === fromItem) {
        return "continue";
      } else if (_typeof(toItem) !== _typeof(fromItem)) {
        res[targetKey] = toItem;
      } else {
        if (_typeof(toItem) !== 'object') {
          res[targetKey] = toItem;
        } else {
          var arrTo = isArray(toItem);
          var arrFrom = isArray(fromItem);

          if (arrTo !== arrFrom) {
            res[targetKey] = toItem;
          } else if (arrTo && arrFrom) {
            if (toItem.length === fromItem.length) {
              diffArrToPath(toItem, fromItem, res, "".concat(targetKey));
            } else {
              res[targetKey] = toItem;
            }
          } else {
            if (!toItem || !fromItem || keyList(toItem).length < keyList(fromItem).length) {
              res[targetKey] = toItem;
            } else {
              // 
              var shouldDiffObject = true;
              Object.keys(fromItem).some(function (key) {
                if (typeof toItem[key] === 'undefined' && typeof fromItem[key] !== 'undefined') {
                  shouldDiffObject = false;
                  return true;
                }
              });

              if (shouldDiffObject) {
                diffObjToPath(toItem, fromItem, res, "".concat(targetKey, "."));
              } else {
                res[targetKey] = toItem;
              }
            }
          }
        }
      }
    };

    for (var i = 0; i < len; i++) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }

    return res;
  } // plainObject


  function diffObjToPath(to, from) {
    var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var keyPrev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var keys = keyList(to);
    var len = keys.length;

    var _loop2 = function _loop2(i) {
      var key = keys[i];
      var toItem = to[key];
      var fromItem = from[key];
      var targetKey = "".concat(keyPrev).concat(key);

      if (toItem === fromItem) {
        return "continue";
      } else if (!hasProp.call(from, key)) {
        res[targetKey] = toItem;
      } else if (_typeof(toItem) !== _typeof(fromItem)) {
        res[targetKey] = toItem;
      } else {
        if (_typeof(toItem) !== 'object') {
          res[targetKey] = toItem;
        } else {
          var arrTo = isArray(toItem);
          var arrFrom = isArray(fromItem);

          if (arrTo !== arrFrom) {
            res[targetKey] = toItem;
          } else if (arrTo && arrFrom) {
            if (toItem.length === fromItem.length) {
              diffArrToPath(toItem, fromItem, res, "".concat(targetKey));
            } else {
              res[targetKey] = toItem;
            }
          } else {
            // null
            if (!toItem || !fromItem) {
              res[targetKey] = toItem;
            } else {
              // 
              var shouldDiffObject = true;
              Object.keys(fromItem).some(function (key) {
                if (typeof toItem[key] === 'undefined' && typeof fromItem[key] !== 'undefined') {
                  shouldDiffObject = false;
                  return true;
                }
              });

              if (shouldDiffObject) {
                diffObjToPath(toItem, fromItem, res, "".concat(targetKey, "."));
              } else {
                res[targetKey] = toItem;
              }
            }
          }
        }
      }
    };

    for (var i = 0; i < len; i++) {
      var _ret2 = _loop2(i);

      if (_ret2 === "continue") continue;
    }

    return res;
  }
  function queryToJson(str) {
    var dec = decodeURIComponent;
    var qp = str.split('&');
    var ret = {};
    var name;
    var val;

    for (var i = 0, l = qp.length, item; i < l; ++i) {
      item = qp[i];

      if (item.length) {
        var s = item.indexOf('=');

        if (s < 0) {
          name = dec(item);
          val = '';
        } else {
          name = dec(item.slice(0, s));
          val = dec(item.slice(s + 1));
        }

        if (typeof ret[name] === 'string') {
          // inline'd type check
          ret[name] = [ret[name]];
        }

        if (isArray(ret[name])) {
          ret[name].push(val);
        } else {
          ret[name] = val;
        }
      }
    }

    return ret; // Object
  }

  var _loadTime = new Date().getTime().toString();

  var _i = 1;
  function getUniqueKey() {
    return _loadTime + _i++;
  }
  function getElementById(component, id, type) {
    if (!component) return null;
    var res;

    if (type === 'component') {
      res = component.selectComponent(id);
      res = res ? res.$component || res : null;
    } else {
      var query = qq.createSelectorQuery().in(component);
      res = query.select(id);
    }

    if (res) return res;
    return null;
  }
  var id$1 = 0;

  function genId() {
    return String(id$1++);
  }

  var compIdsMapper;

  try {
    compIdsMapper = new Map();
  } catch (error) {
    compIdsMapper = new SimpleMap();
  }

  function genCompid(key) {
    if (!taro.Current || !taro.Current.current || !taro.Current.current.$scope) return;
    var prevId = compIdsMapper.get(key);
    var id = prevId || genId();
    !prevId && compIdsMapper.set(key, id);
    return id;
  }
  var prefix = 0;
  function genCompPrefix() {
    return String(prefix++);
  }

  var data = {};
  function cacheDataSet(key, val) {
    data[key] = val;
  }
  function cacheDataGet(key, delelteAfterGet) {
    var temp = data[key];
    delelteAfterGet && delete data[key];
    return temp;
  }
  function cacheDataHas(key) {
    return key in data;
  }

  var Manager =
  /*#__PURE__*/
  function () {
    function Manager() {
      _classCallCheck(this, Manager);

      _defineProperty(this, "map", {});

      _defineProperty(this, "observers", {});
    }

    _createClass(Manager, [{
      key: "set",
      value: function set() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var compid = arguments.length > 1 ? arguments[1] : undefined;
        if (!compid) return;
        var observers = this.observers;

        if (!this.map[compid]) {
          Object.defineProperty(this.map, compid, {
            configurable: true,
            get: function get() {
              return this["__".concat(compid)];
            },
            set: function set(props) {
              this["__".concat(compid)] = props;
              var component = observers[compid] && observers[compid].component;
              var ComponentClass = observers[compid] && observers[compid].ComponentClass;
              if (!component || !ComponentClass || !component.__isReady) return;
              var nextProps = filterProps(ComponentClass.defaultProps, props, component.props);
              component.props = nextProps;
              nextTick(function () {
                component._unsafeCallUpdate = true;
                updateComponent(component);
                component._unsafeCallUpdate = false;
              });
            }
          });
        }

        this.map[compid] = props;
      }
    }, {
      key: "delete",
      value: function _delete(compid) {
        delete this.map[compid];
        delete this.map["__".concat(compid)];
        delete this.observers[compid];
      }
    }]);

    return Manager;
  }();

  var propsManager = new Manager();

  var anonymousFnNamePreffix = 'funPrivate';
  var routerParamsPrivateKey = '__key_';
  var preloadPrivateKey = '__preload_';
  var PRELOAD_DATA_KEY = 'preload';
  var preloadInitedComponent = '$preloadComponent';
  var pageExtraFns = ['onPullDownRefresh', 'onReachBottom', 'onShareAppMessage', 'onPageScroll', 'onTabItemTap', 'onResize'];

  function bindProperties(weappComponentConf, ComponentClass, isPage) {
    weappComponentConf.properties = {};

    if (isPage) {
      weappComponentConf.properties[routerParamsPrivateKey] = {
        type: null,
        value: null
      };
      weappComponentConf.properties[preloadPrivateKey] = {
        type: null,
        value: null
      };
      var defaultParams = ComponentClass.defaultParams || {};

      for (var key in defaultParams) {
        if (defaultParams.hasOwnProperty(key)) {
          weappComponentConf.properties[key] = {
            type: null,
            value: null
          };
        }
      }
    }

    weappComponentConf.properties.compid = {
      type: null,
      value: null,
      observer: function observer() {
        initComponent.apply(this, [ComponentClass, isPage]);
      }
    };
  }

  function bindBehaviors(weappComponentConf, ComponentClass) {
    if (ComponentClass.behaviors) {
      weappComponentConf.behaviors = ComponentClass.behaviors;
    }
  }

  function bindStaticOptions(weappComponentConf, ComponentClass) {
    if (ComponentClass.options) {
      weappComponentConf.options = ComponentClass.options;
    }
  }

  function bindMultipleSlots(weappComponentConf, ComponentClass) {
    var multipleSlots = ComponentClass.multipleSlots;

    if (!multipleSlots) {
      return;
    }

    weappComponentConf.options = _objectSpread({}, weappComponentConf.options, {
      multipleSlots: multipleSlots
    });
  }

  function bindStaticFns(weappComponentConf, ComponentClass) {
    for (var key in ComponentClass) {
      typeof ComponentClass[key] === 'function' && (weappComponentConf[key] = ComponentClass[key]);
    } //  IOS 


    Object.getOwnPropertyNames(ComponentClass).forEach(function (key) {
      var excludes = ['arguments', 'caller', 'length', 'name', 'prototype'];

      if (excludes.indexOf(key) < 0) {
        typeof ComponentClass[key] === 'function' && (weappComponentConf[key] = ComponentClass[key]);
      }
    });
  }

  function processEvent(eventHandlerName, obj) {
    if (obj[eventHandlerName]) return;

    obj[eventHandlerName] = function (event) {
      if (event) {
        event.preventDefault = function () {};

        event.stopPropagation = function () {};

        event.currentTarget = event.currentTarget || event.target || {};

        if (event.target) {
          Object.assign(event.target, event.detail);
        }

        Object.assign(event.currentTarget, event.detail);
      }

      var scope = this.$component;
      var callScope = scope;
      var isAnonymousFn = eventHandlerName.indexOf(anonymousFnNamePreffix) > -1;
      var realArgs = [];
      var detailArgs = [];
      var datasetArgs = [];
      var isScopeBinded = false; // dataset

      var dataset = event.currentTarget.dataset || {};
      var bindArgs = {};
      var eventType = event.type.toLocaleLowerCase();
      Object.keys(dataset).forEach(function (key) {
        var keyLower = key.toLocaleLowerCase();

        if (/^e/.test(keyLower)) {
          // 
          keyLower = keyLower.replace(/^e/, '');

          if (keyLower.indexOf(eventType) >= 0) {
            var argName = keyLower.replace(eventType, '');

            if (/^(a[a-z]|so)$/.test(argName)) {
              bindArgs[argName] = dataset[key];
            }
          }
        }
      }); // triggerEvent,

      if (event.detail && event.detail.__arguments && event.detail.__arguments.length > 0) {
        detailArgs = event.detail.__arguments;
      } // call


      if (!isAnonymousFn) {
        if ('so' in bindArgs) {
          if (bindArgs['so'] !== 'this') {
            callScope = bindArgs['so'];
          }

          isScopeBinded = true;
          delete bindArgs['so'];
        }

        if (detailArgs.length > 0) {
          !isScopeBinded && detailArgs[0] && (callScope = detailArgs[0]);
          detailArgs.shift();
        }

        if (!isEmptyObject(bindArgs)) {
          datasetArgs = Object.keys(bindArgs).sort().map(function (key) {
            return bindArgs[key];
          });
        }

        realArgs = _toConsumableArray(datasetArgs).concat(_toConsumableArray(detailArgs), [event]);
      } else {
        // scope
        var _scope = null;

        if ('so' in bindArgs) {
          if (bindArgs['so'] !== 'this') {
            _scope = bindArgs['so'];
          }

          isScopeBinded = true;
          delete bindArgs['so'];
        }

        if (detailArgs.length > 0) {
          !isScopeBinded && detailArgs[0] && (callScope = detailArgs[0]);
          detailArgs.shift();
        }

        if (!isEmptyObject(bindArgs)) {
          datasetArgs = Object.keys(bindArgs).sort().map(function (key) {
            return bindArgs[key];
          });
        }

        realArgs = [_scope].concat(_toConsumableArray(datasetArgs), _toConsumableArray(detailArgs), [event]);
      }

      return scope[eventHandlerName].apply(callScope, realArgs);
    };
  }

  function bindEvents(weappComponentConf, events, isPage) {
    weappComponentConf.methods = weappComponentConf.methods || {};
    var target = weappComponentConf.methods;
    events.forEach(function (name) {
      processEvent(name, target);
    });
  }

  function filterProps() {
    var defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var propsFromPropsManager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var curAllProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var newProps = Object.assign({}, curAllProps, propsFromPropsManager);

    if (!isEmptyObject(defaultProps)) {
      for (var propName in defaultProps) {
        if (newProps[propName] === undefined) {
          newProps[propName] = defaultProps[propName];
        }
      }
    }

    return newProps;
  }

  function filterParams(data) {
    var defaultParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var res = {};

    for (var paramName in defaultParams) {
      res[paramName] = paramName in data ? data[paramName] : defaultParams[paramName];
    }

    return res;
  }

  function componentTrigger(component, key, args) {
    var _component$key;

    args = args || [];

    if (key === 'componentDidMount') {
      if (component['$$refs'] && component['$$refs'].length > 0) {
        var refs = {};
        component['$$refs'].forEach(function (ref) {
          var target;

          if (ref.type === 'component') {
            target = component.$scope.selectComponent("#".concat(ref.id));
            target = target ? target.$component || target : null;
          } else {
            var query = qq.createSelectorQuery().in(component.$scope);
            target = query.select("#".concat(ref.id));
          }

          taro.commitAttachRef(ref, target, component, refs, true);
          ref.target = target;
        });
        component.refs = Object.assign({}, component.refs || {}, refs);
      }

      if (component['$$hasLoopRef']) {
        taro.Current.current = component;
        component._disableEffect = true;

        component._createData(component.state, component.props, true);

        component._disableEffect = false;
        taro.Current.current = null;
      }
    }

    if (key === 'componentWillUnmount') {
      var compid = component.$scope.data.compid;
      if (compid) propsManager.delete(compid);
    }

    component[key] && typeof component[key] === 'function' && (_component$key = component[key]).call.apply(_component$key, [component].concat(_toConsumableArray(args)));

    if (key === 'componentWillMount') {
      component._dirty = false;
      component._disable = false;
      component.state = component.getState();
    }

    if (key === 'componentWillUnmount') {
      component._dirty = true;
      component._disable = true;
      component.$router = {
        params: {},
        path: ''
      };
      component._pendingStates = [];
      component._pendingCallbacks = []; // refs

      taro.detachAllRef(component);
    }
  }

  function initComponent(ComponentClass, isPage) {
    if (this.$component.__isReady) return; // readysetData,
    // readyobserver__isReadyobserver

    this.$component.__isReady = true; // ReadysetDatadidMount,observer
    // readyreadyupdateComponentsetDataready
    // ,props

    if (!isPage) {
      var compid = this.data.compid;

      if (compid) {
        propsManager.observers[compid] = {
          component: this.$component,
          ComponentClass: ComponentClass
        };
      }

      var nextProps = filterProps(ComponentClass.defaultProps, propsManager.map[compid], this.$component.props);
      this.$component.props = nextProps;
    } else {
      this.$component.$router.path = getCurrentPageUrl();
    }

    mountComponent(this.$component);
  }

  function createComponent(ComponentClass, isPage) {
    var initData = {};
    var componentProps = filterProps(ComponentClass.defaultProps);
    var componentInstance = new ComponentClass(componentProps);
    componentInstance._constructor && componentInstance._constructor(componentProps);

    try {
      taro.Current.current = componentInstance;
      taro.Current.index = 0;
      componentInstance.state = componentInstance._createData() || componentInstance.state;
    } catch (err) {
      if (isPage) {
        console.warn("[Taro warn] \u8BF7\u7ED9\u9875\u9762\u63D0\u4F9B\u521D\u59CB `state` \u4EE5\u63D0\u9AD8\u521D\u6B21\u6E32\u67D3\u6027\u80FD\uFF01");
      } else {
        console.warn("[Taro warn] \u8BF7\u7ED9\u7EC4\u4EF6\u63D0\u4F9B\u4E00\u4E2A `defaultProps` \u4EE5\u63D0\u9AD8\u521D\u6B21\u6E32\u67D3\u6027\u80FD\uFF01");
      }

      console.warn(err);
    }

    initData = Object.assign({}, initData, componentInstance.props, componentInstance.state);
    var weappComponentConf = {
      data: initData,
      created: function created() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (isPage && cacheDataHas(preloadInitedComponent)) {
          this.$component = cacheDataGet(preloadInitedComponent, true);
          this.$component.$componentType = 'PAGE';
        } else {
          this.$component = new ComponentClass({}, isPage);
        }

        this.$component._init(this);

        this.$component.render = this.$component._createData;
        this.$component.__propTypes = ComponentClass.propTypes;
        Object.assign(this.$component.$router.params, options);
      },
      attached: function attached() {
        var hasParamsCache;

        if (isPage) {
          // params
          var params = {};
          hasParamsCache = cacheDataHas(this.data[routerParamsPrivateKey]);

          if (hasParamsCache) {
            params = Object.assign({}, ComponentClass.defaultParams, cacheDataGet(this.data[routerParamsPrivateKey], true));
          } else {
            // 
            params = filterParams(this.data, ComponentClass.defaultParams);
          }

          if (cacheDataHas(PRELOAD_DATA_KEY)) {
            var data = cacheDataGet(PRELOAD_DATA_KEY, true);
            this.$component.$router.preload = data;
          }

          Object.assign(this.$component.$router.params, params); // preload

          if (cacheDataHas(this.data[preloadPrivateKey])) {
            this.$component.$preloadData = cacheDataGet(this.data[preloadPrivateKey], true);
          } else {
            this.$component.$preloadData = null;
          }
        }

        if (hasParamsCache || !isPage) {
          initComponent.apply(this, [ComponentClass, isPage]);
        }
      },
      ready: function ready() {
        if (!isPage && !this.$component.__mounted) {
          this.$component.__mounted = true;
          componentTrigger(this.$component, 'componentDidMount');
        }
      },
      detached: function detached() {
        var component = this.$component;
        componentTrigger(component, 'componentWillUnmount');
        component.hooks.forEach(function (hook) {
          if (isFunction(hook.cleanup)) {
            hook.cleanup();
          }
        });
        var events = component.$$renderPropsEvents;

        if (isArray(events)) {
          events.forEach(function (e) {
            return taro.eventCenter.off(e);
          });
        }
      }
    };

    if (isPage) {
      weappComponentConf.methods = weappComponentConf.methods || {};

      weappComponentConf.methods['onLoad'] = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this.$component.__isReady) return;
        Object.assign(this.$component.$router.params, options);
        initComponent.apply(this, [ComponentClass, isPage]);
      };

      weappComponentConf.methods['onReady'] = function () {
        this.$component.__mounted = true;
        componentTrigger(this.$component, 'componentDidMount');
      };

      weappComponentConf.methods['onShow'] = function () {
        componentTrigger(this.$component, 'componentDidShow');
      };

      weappComponentConf.methods['onHide'] = function () {
        componentTrigger(this.$component, 'componentDidHide');
      };

      pageExtraFns.forEach(function (fn) {
        if (componentInstance[fn] && typeof componentInstance[fn] === 'function') {
          weappComponentConf.methods[fn] = function () {
            var component = this.$component;

            if (component[fn] && typeof component[fn] === 'function') {
              var _component$fn;

              return (_component$fn = component[fn]).call.apply(_component$fn, [component].concat(Array.prototype.slice.call(arguments)));
            }
          };
        }
      });
      __wxRoute && cacheDataSet(__wxRoute, ComponentClass);
    } else {
      weappComponentConf.pageLifetimes = weappComponentConf.pageLifetimes || {};

      weappComponentConf.pageLifetimes['show'] = function () {
        componentTrigger(this.$component, 'componentDidShow');
      };

      weappComponentConf.pageLifetimes['hide'] = function () {
        componentTrigger(this.$component, 'componentDidHide');
      };

      weappComponentConf.pageLifetimes['resize'] = function () {
        componentTrigger(this.$component, 'onResize');
      };
    }

    bindProperties(weappComponentConf, ComponentClass, isPage);
    bindBehaviors(weappComponentConf, ComponentClass);
    bindStaticFns(weappComponentConf, ComponentClass);
    bindStaticOptions(weappComponentConf, ComponentClass);
    bindMultipleSlots(weappComponentConf, ComponentClass);
    ComponentClass['$$events'] && bindEvents(weappComponentConf, ComponentClass['$$events'], isPage);

    if (ComponentClass['externalClasses'] && ComponentClass['externalClasses'].length) {
      weappComponentConf['externalClasses'] = ComponentClass['externalClasses'];
    }

    return weappComponentConf;
  }

  var isDEV = typeof process === 'undefined' || !process.env || process.env.NODE_ENV !== 'production';

  function hasNewLifecycle(component) {
    var getDerivedStateFromProps = component.constructor.getDerivedStateFromProps,
        getSnapshotBeforeUpdate = component.getSnapshotBeforeUpdate;
    return isFunction(getDerivedStateFromProps) || isFunction(getSnapshotBeforeUpdate);
  }

  function callGetDerivedStateFromProps(component, props, state) {
    var getDerivedStateFromProps = component.constructor.getDerivedStateFromProps;
    var newState;

    if (isFunction(getDerivedStateFromProps)) {
      var partialState = getDerivedStateFromProps(props, state);

      if (!isUndefined(partialState)) {
        newState = Object.assign({}, state, partialState);
      } else {
        console.warn('getDerivedStateFromProps  null ');
      }
    }

    return newState;
  }

  function callGetSnapshotBeforeUpdate(component, props, state) {
    var getSnapshotBeforeUpdate = component.getSnapshotBeforeUpdate;
    var snapshot;

    if (isFunction(getSnapshotBeforeUpdate)) {
      snapshot = getSnapshotBeforeUpdate.call(component, props, state);
    }

    return snapshot;
  }

  function updateComponent(component) {
    var props = component.props,
        __propTypes = component.__propTypes;

    if (isDEV && __propTypes) {
      var componentName = component.constructor.name;

      if (isUndefined(componentName)) {
        var names = component.constructor.toString().match(/^function\s*([^\s(]+)/);
        componentName = isArray(names) ? names[0] : 'Component';
      }

      propTypes.checkPropTypes(__propTypes, props, 'prop', componentName);
    }

    var prevProps = component.prevProps || props;
    component.props = prevProps;

    if (component.__mounted && component._unsafeCallUpdate === true && !hasNewLifecycle(component) && component.componentWillReceiveProps) {
      component._disable = true;
      component.componentWillReceiveProps(props);
      component._disable = false;
    }

    var state = component.getState();
    var prevState = component.prevState || state;
    var stateFromProps = callGetDerivedStateFromProps(component, props, state);

    if (!isUndefined(stateFromProps)) {
      state = stateFromProps;
    }

    var skip = false;

    if (component.__mounted) {
      if (typeof component.shouldComponentUpdate === 'function' && !component._isForceUpdate && component.shouldComponentUpdate(props, state) === false) {
        skip = true;
      } else if (!hasNewLifecycle(component) && isFunction(component.componentWillUpdate)) {
        component.componentWillUpdate(props, state);
      }
    }

    component.props = props;
    component.state = state;
    component._dirty = false;
    component._isForceUpdate = false;

    if (!skip) {
      doUpdate(component, prevProps, prevState);
    }

    component.prevProps = component.props;
    component.prevState = component.state;
  }

  function injectContextType(component) {
    var ctxType = component.constructor.contextType;

    if (ctxType) {
      var context = ctxType.context;
      var emiter = context.emiter;

      if (emiter === null) {
        component.context = context._defaultValue;
        return;
      }

      if (!component._hasContext) {
        component._hasContext = true;
        emiter.on(function (_) {
          return enqueueRender(component);
        });
      }

      component.context = emiter.value;
    }
  }

  function mountComponent(component) {
    var props = component.props; // willMount

    if (!component.__componentWillMountTriggered) {
      component._constructor && component._constructor(props);
    }

    var newState = callGetDerivedStateFromProps(component, props, component.state);

    if (!isUndefined(newState)) {
      component.state = newState;
    }

    component._dirty = false;
    component._disable = false;
    component._isForceUpdate = false;

    if (!component.__componentWillMountTriggered) {
      component.__componentWillMountTriggered = true;

      if (!hasNewLifecycle(component)) {
        componentTrigger(component, 'componentWillMount');
      }
    }

    doUpdate(component, props, component.state);
    component.prevProps = component.props;
    component.prevState = component.state;
  }

  function doUpdate(component, prevProps, prevState) {
    var state = component.state,
        _component$props = component.props,
        props = _component$props === void 0 ? {} : _component$props;
    var data = state || {};

    if (component._createData) {
      if (component.__isReady) {
        injectContextType(component);
        taro.Current.current = component;
        taro.Current.index = 0;
        taro.invokeEffects(component, true);
      }

      data = component._createData(state, props) || data;

      if (component.__isReady) {
        taro.Current.current = null;
      }
    }

    data = Object.assign({}, props, data);

    if (component.$usedState && component.$usedState.length) {
      var _data = {};
      component.$usedState.forEach(function (key) {
        var val = taro.internal_safe_get(data, key);

        if (typeof val === 'undefined') {
          return;
        }

        if (_typeof(val) === 'object') {
          if (isEmptyObject(val)) return taro.internal_safe_set(_data, key, val);
          val = shakeFnFromObject(val); //  Fn 

          if (!isEmptyObject(val)) taro.internal_safe_set(_data, key, val);
        } else {
          taro.internal_safe_set(_data, key, val);
        }
      });
      data = _data;
    }

    data['$taroCompReady'] = true;
    var dataDiff = diffObjToPath(data, component.$scope.data);
    var __mounted = component.__mounted;
    var snapshot;

    if (__mounted) {
      snapshot = callGetSnapshotBeforeUpdate(component, prevProps, prevState);
    } //  setData  callback 


    var cbs = [];

    if (component._pendingCallbacks && component._pendingCallbacks.length) {
      cbs = component._pendingCallbacks;
      component._pendingCallbacks = [];
    }

    var cb = function cb() {
      if (__mounted) {
        taro.invokeEffects(component);

        if (component['$$refs'] && component['$$refs'].length > 0) {
          component['$$refs'].forEach(function (ref) {
            //  component  querySelector  nodeRefs dom 
            if (ref.type !== 'component') return;
            var target = component.$scope.selectComponent("#".concat(ref.id));
            target = target ? target.$component || target : null;
            var prevRef = ref.target;

            if (target !== prevRef) {
              taro.commitAttachRef(ref, target, component, component.refs);
              ref.target = target;
            }
          });
        }

        if (component['$$hasLoopRef']) {
          taro.Current.current = component;
          component._disableEffect = true;

          component._createData(component.state, component.props, true);

          component._disableEffect = false;
          taro.Current.current = null;
        }

        if (typeof component.componentDidUpdate === 'function') {
          component.componentDidUpdate(prevProps, prevState, snapshot);
        }
      }

      if (cbs.length) {
        var i = cbs.length;

        while (--i >= 0) {
          typeof cbs[i] === 'function' && cbs[i].call(component);
        }
      }
    };

    if (Object.keys(dataDiff).length === 0) {
      cb();
    } else {
      component.$scope.setData(dataDiff, cb);
    }
  }

  var items = [];
  function enqueueRender(component) {
    var isForceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    // tslint:disable-next-line:no-conditional-assignment
    component._isForceUpdate = isForceUpdate;

    if (!component._dirty && (component._dirty = true) && items.push(component) === 1) {
      nextTick(function () {
        rerender();
      });
    }
  }
  function rerender() {
    var p;
    var list = items;
    items = []; // tslint:disable-next-line:no-conditional-assignment

    while (p = list.pop()) {
      if (p._dirty) {
        updateComponent(p, true);
      }
    }
  }

  // #__componentPropsobsevercomponentWillReceiveProps,componentShouldUpdate
  // #propsdata.__propsreceiveProps
  // setState -> _createData() -> setData-> __componentProps.observer
  //          -> componentWillReceivePropsprops,componentShouldUpdate -> _createData -> setData

  var PRELOAD_DATA_KEY$1 = 'preload';

  var BaseComponent =
  /*#__PURE__*/
  function () {
    // _createDatadata.__createData
    // this.props,data.__props
    // componentDidMounttrue
    function BaseComponent() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var isPage = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, BaseComponent);

      _defineProperty(this, "__computed", {});

      _defineProperty(this, "__props", {});

      _defineProperty(this, "__isReady", false);

      _defineProperty(this, "__mounted", false);

      _defineProperty(this, "nextProps", {});

      _defineProperty(this, "_dirty", true);

      _defineProperty(this, "_disable", true);

      _defineProperty(this, "_isForceUpdate", false);

      _defineProperty(this, "_pendingStates", []);

      _defineProperty(this, "_pendingCallbacks", []);

      _defineProperty(this, "$componentType", '');

      _defineProperty(this, "$router", {
        params: {},
        path: ''
      });

      _defineProperty(this, "_afterScheduleEffect", false);

      _defineProperty(this, "_disableEffect", false);

      _defineProperty(this, "hooks", []);

      _defineProperty(this, "effects", []);

      _defineProperty(this, "layoutEffects", []);

      this.state = {};
      this.props = props;
      this.$componentType = isPage ? 'PAGE' : 'COMPONENT';
      this.$prefix = genCompPrefix();
      this.isTaroComponent = this.$componentType && this.$router && this._pendingStates;
    }

    _createClass(BaseComponent, [{
      key: "_constructor",
      value: function _constructor(props) {
        this.props = props || {};
      }
    }, {
      key: "_init",
      value: function _init(scope) {
        this.$scope = scope;
      }
    }, {
      key: "setState",
      value: function setState(state, callback) {
        if (state) {
          (this._pendingStates = this._pendingStates || []).push(state);
        }

        if (isFunction(callback)) {
          (this._pendingCallbacks = this._pendingCallbacks || []).push(callback);
        }

        if (!this._disable) {
          enqueueRender(this, callback === taro.internal_force_update);
        }
      }
    }, {
      key: "getState",
      value: function getState() {
        var _this = this;

        var _pendingStates = this._pendingStates,
            state = this.state,
            props = this.props;
        var stateClone = Object.assign({}, state);
        delete stateClone.__data;

        if (!_pendingStates.length) {
          return stateClone;
        }

        var queue = _pendingStates.concat();

        this._pendingStates.length = 0;
        queue.forEach(function (nextState) {
          if (isFunction(nextState)) {
            nextState = nextState.call(_this, stateClone, props);
          }

          Object.assign(stateClone, nextState);
        });
        return stateClone;
      }
    }, {
      key: "forceUpdate",
      value: function forceUpdate(callback) {
        if (isFunction(callback)) {
          (this._pendingCallbacks = this._pendingCallbacks || []).push(callback);
        }

        this._isForceUpdate = true;
        updateComponent(this);
      }
    }, {
      key: "$preload",
      value: function $preload(key, value) {
        var preloadData = cacheDataGet(PRELOAD_DATA_KEY$1) || {};

        if (_typeof(key) === 'object') {
          for (var k in key) {
            preloadData[k] = key[k];
          }
        } else {
          preloadData[key] = value;
        }

        cacheDataSet(PRELOAD_DATA_KEY$1, preloadData);
      } // 

    }, {
      key: "__triggerPropsFn",
      value: function __triggerPropsFn(key, args) {
        var keyChain = key.split('.');
        var reduxFnPrefix = '__event_';
        var reduxFnName = reduxFnPrefix + keyChain.shift(); // redux

        if (reduxFnName in this) {
          var scope = args.shift();
          var fn;

          if (keyChain.length > 0) {
            fn = taro.internal_safe_get(this[reduxFnName], keyChain.join('.'));
          } else {
            fn = this[reduxFnName];
          }

          fn.apply(scope, args);
        } else {
          // 
          var keyLower = key.toLocaleLowerCase();
          var detail = {
            __isCustomEvt: true,
            __arguments: args
          };

          if (args.length > 0) {
            detail.value = args.slice(1);
          }

          this.$scope.triggerEvent(keyLower, detail);
        }
      }
    }]);

    return BaseComponent;
  }();

  var PureComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(PureComponent, _Component);

    function PureComponent() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, PureComponent);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PureComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isPureComponent", true);

      return _this;
    }

    _createClass(PureComponent, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
      }
    }]);

    return PureComponent;
  }(BaseComponent);

  function createApp(AppClass) {
    var app = new AppClass();
    var weappAppConf = {
      onLaunch: function onLaunch(options) {
        app.$app = this;
        app.$app.$router = app.$router = {
          params: options
        };

        if (app.componentWillMount) {
          app.componentWillMount();
        }

        if (app.componentDidMount) {
          app.componentDidMount();
        }
      },
      onShow: function onShow(options) {
        Object.assign(app.$router.params, options);

        if (app.componentDidShow) {
          app.componentDidShow();
        }
      },
      onHide: function onHide() {
        if (app.componentDidHide) {
          app.componentDidHide();
        }
      },
      onError: function onError(err) {
        if (app.componentDidCatchError) {
          app.componentDidCatchError(err);
        }
      },
      onPageNotFound: function onPageNotFound(obj) {
        if (app.componentDidNotFound) {
          app.componentDidNotFound(obj);
        }
      }
    };
    return Object.assign(weappAppConf, app);
  }

  var RequestQueue = {
    MAX_REQUEST: 5,
    queue: [],
    request: function request(options) {
      this.push(options); // request task

      return this.run();
    },
    push: function push(options) {
      this.queue.push(options);
    },
    run: function run() {
      var _this = this;

      if (!this.queue.length) {
        return;
      }

      if (this.queue.length <= this.MAX_REQUEST) {
        var options = this.queue.shift();
        var completeFn = options.complete;

        options.complete = function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          completeFn && completeFn.apply(options, args);

          _this.run();
        };

        return qq.request(options);
      }
    }
  };

  function taroInterceptor(chain) {
    return request(chain.requestParams);
  }

  var link = new taro.Link(taroInterceptor);

  function request(options) {
    options = options || {};

    if (typeof options === 'string') {
      options = {
        url: options
      };
    }

    var originSuccess = options['success'];
    var originFail = options['fail'];
    var originComplete = options['complete'];
    var requestTask;
    var p = new Promise(function (resolve, reject) {
      options['success'] = function (res) {
        originSuccess && originSuccess(res);
        resolve(res);
      };

      options['fail'] = function (res) {
        originFail && originFail(res);
        reject(res);
      };

      options['complete'] = function (res) {
        originComplete && originComplete(res);
      };

      requestTask = RequestQueue.request(options);
    });

    p.abort = function (cb) {
      cb && cb();

      if (requestTask) {
        requestTask.abort();
      }

      return p;
    };

    return p;
  }

  function processApis(taro$$1) {
    var weApis = Object.assign({}, taro.onAndSyncApis, taro.noPromiseApis, taro.otherApis);
    var useDataCacheApis = {
      'navigateTo': true,
      'redirectTo': true,
      'reLaunch': true
    };
    var routerParamsPrivateKey = '__key_';
    var preloadPrivateKey = '__preload_';
    var preloadInitedComponent = '$preloadComponent';
    Object.keys(weApis).forEach(function (key) {
      if (!(key in qq)) {
        taro$$1[key] = function () {
          console.warn("QQ\u5C0F\u7A0B\u5E8F\u6682\u4E0D\u652F\u6301 ".concat(key));
        };

        return;
      }

      if (!taro.onAndSyncApis[key] && !taro.noPromiseApis[key]) {
        taro$$1[key] = function (options) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          options = options || {};
          var task = null;
          var obj = Object.assign({}, options);

          if (typeof options === 'string') {
            if (args.length) {
              var _qq;

              return (_qq = qq)[key].apply(_qq, [options].concat(args));
            }

            return qq[key](options);
          }

          if (key === 'navigateTo' || key === 'redirectTo' || key === 'switchTab') {
            var url = obj['url'] ? obj['url'].replace(/^\//, '') : '';
            if (url.indexOf('?') > -1) url = url.split('?')[0];
            var Component = cacheDataGet(url);

            if (Component) {
              var component = new Component();

              if (component.componentWillPreload) {
                var cacheKey = getUniqueKey();
                var MarkIndex = obj.url.indexOf('?');
                var hasMark = MarkIndex > -1;
                var urlQueryStr = hasMark ? obj.url.substring(MarkIndex + 1, obj.url.length) : '';
                var params = queryToJson(urlQueryStr);
                obj.url += (hasMark ? '&' : '?') + "".concat(preloadPrivateKey, "=").concat(cacheKey);
                cacheDataSet(cacheKey, component.componentWillPreload(params));
                cacheDataSet(preloadInitedComponent, component);
              }
            }
          }

          if (useDataCacheApis[key]) {
            var _url = obj['url'] = obj['url'] || '';

            var _MarkIndex = _url.indexOf('?');

            var _hasMark = _MarkIndex > -1;

            var _urlQueryStr = _hasMark ? _url.substring(_MarkIndex + 1, _url.length) : '';

            var _params = queryToJson(_urlQueryStr);

            var _cacheKey = getUniqueKey();

            obj.url += (_hasMark ? '&' : '?') + "".concat(routerParamsPrivateKey, "=").concat(_cacheKey);
            cacheDataSet(_cacheKey, _params);
          }

          var p = new Promise(function (resolve, reject) {
            ['fail', 'success', 'complete'].forEach(function (k) {
              obj[k] = function (res) {
                options[k] && options[k](res);

                if (k === 'success') {
                  if (key === 'connectSocket') {
                    resolve(Promise.resolve().then(function () {
                      return Object.assign(task, res);
                    }));
                  } else {
                    resolve(res);
                  }
                } else if (k === 'fail') {
                  reject(res);
                }
              };
            });

            if (args.length) {
              var _qq2;

              task = (_qq2 = qq)[key].apply(_qq2, [obj].concat(args));
            } else {
              task = qq[key](obj);
            }
          });

          if (key === 'uploadFile' || key === 'downloadFile') {
            p.progress = function (cb) {
              if (task) {
                task.onProgressUpdate(cb);
              }

              return p;
            };

            p.abort = function (cb) {
              cb && cb();

              if (task) {
                task.abort();
              }

              return p;
            };
          }

          return p;
        };
      } else {
        taro$$1[key] = function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          var argsLen = args.length;
          var newArgs = args.concat();
          var lastArg = newArgs[argsLen - 1];

          if (lastArg && lastArg.isTaroComponent && lastArg.$scope) {
            newArgs.splice(argsLen - 1, 1, lastArg.$scope);
          }

          return qq[key].apply(qq, newArgs);
        };
      }
    });
  }

  function pxTransform(size) {
    var _ref = this.config || {},
        _ref$designWidth = _ref.designWidth,
        designWidth = _ref$designWidth === void 0 ? 750 : _ref$designWidth,
        _ref$deviceRatio = _ref.deviceRatio,
        deviceRatio = _ref$deviceRatio === void 0 ? {
      '640': 2.34 / 2,
      '750': 1,
      '828': 1.81 / 2
    } : _ref$deviceRatio;

    if (!(designWidth in deviceRatio)) {
      throw new Error("deviceRatio \u914D\u7F6E\u4E2D\u4E0D\u5B58\u5728 ".concat(designWidth, " \u7684\u8BBE\u7F6E\uFF01"));
    }

    return parseInt(size, 10) / deviceRatio[designWidth] + 'rpx';
  }

  function canIUseWebp() {
    var _qq$getSystemInfoSync = qq.getSystemInfoSync(),
        platform = _qq$getSystemInfoSync.platform;

    var platformLower = platform.toLowerCase();

    if (platformLower === 'android' || platformLower === 'devtools') {
      return true;
    }

    return false;
  }

  function qqCloud(taro$$1) {
    var qqC = qq.cloud || {};
    var qqcloud = {};
    var apiList = ['init', 'database', 'uploadFile', 'downloadFile', 'getTempFileURL', 'deleteFile', 'callFunction'];
    apiList.forEach(function (v) {
      qqcloud[v] = qqC[v];
    });
    taro$$1.cloud = qqcloud;
  }

  function initNativeApi(taro$$1) {
    processApis(taro$$1);
    taro$$1.request = link.request.bind(link);
    taro$$1.addInterceptor = link.addInterceptor.bind(link);
    taro$$1.cleanInterceptors = link.cleanInterceptors.bind(link);
    taro$$1.getCurrentPages = getCurrentPages;
    taro$$1.getApp = getApp;
    taro$$1.requirePlugin = requirePlugin;
    taro$$1.initPxTransform = taro.initPxTransform.bind(taro$$1);
    taro$$1.pxTransform = pxTransform.bind(taro$$1);
    taro$$1.canIUseWebp = canIUseWebp;
    qqCloud(taro$$1);
  }

  /* eslint-disable camelcase */
  var Taro = {
    Component: BaseComponent,
    PureComponent: PureComponent,
    createApp: createApp,
    initNativeApi: initNativeApi,
    Events: taro.Events,
    eventCenter: taro.eventCenter,
    getEnv: taro.getEnv,
    render: taro.render,
    ENV_TYPE: taro.ENV_TYPE,
    createRef: taro.createRef,
    internal_safe_get: taro.internal_safe_get,
    internal_safe_set: taro.internal_safe_set,
    internal_inline_style: taro.internal_inline_style,
    createComponent: createComponent,
    internal_get_original: taro.internal_get_original,
    getElementById: getElementById,
    propsManager: propsManager,
    interceptors: taro.interceptors,
    genCompid: genCompid,
    // eslint-disable-next-line object-property-newline
    useEffect: taro.useEffect,
    useLayoutEffect: taro.useLayoutEffect,
    useReducer: taro.useReducer,
    useState: taro.useState,
    useRef: taro.useRef,
    useCallback: taro.useCallback,
    useMemo: taro.useMemo,
    useDidShow: taro.useDidShow,
    useDidHide: taro.useDidHide,
    usePullDownRefresh: taro.usePullDownRefresh,
    useReachBottom: taro.useReachBottom,
    usePageScroll: taro.usePageScroll,
    useResize: taro.useResize,
    useShareAppMessage: taro.useShareAppMessage,
    useTabItemTap: taro.useTabItemTap,
    useRouter: taro.useRouter,
    useImperativeHandle: taro.useImperativeHandle,
    useContext: taro.useContext,
    createContext: taro.createContext,
    memo: taro.memo,
    shallowEqual: shallowEqual
  };
  initNativeApi(Taro);

  exports.Taro = Taro;
  exports.default = Taro;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taro-qq.js.map
